# Map

**Key** - **Value** 형태로 데이터를 저장하고 있는 것을 **Map**이라고 한다.

>  대표적인 예시는 다음과 같다.
>
> 전화번호부
>
> 김AA - "010 ..."
>
> 김BB - "010..."
>
> 김CC - "010..."

이 처럼 김AA라는 키 값과 "010..." 밸류 값으로 쌍으로 짝지어진 형태를 Map이라고 한다. 

- Map
- Dictionary

라고도 한다.

>  kv●kv●kv●kv●kv●kv●kv

위 와같이 저장 되어 있을 때 키 값을 하나하나 대조해서 밸류 값을 얻어낸다. 하지만 이러한 배열로 이루어진 것은 O(N)의 속도를 가지기 때문에 좋지않다.

>​                        5
>
>​                      /     \
>
>​                   3            8
>
>​               /      \         /      \
>
>​           2           4     7             9

 위 와 같이 BST를 사용해서 만들게 되면 $log_2N$의 속도로 값을 얻어낼 수 있다.

이를 **Sorted Map**이라고도 하고 **Ordered Map**이라고도 한다.:smile:



우리가 알아볼 **Map**은 **Hash Map**이다.

### Hash Map

김AA   -->  |--------------------|   -->   1         1 ~ 10 사이의 값

김BB   --> |          Hash      |    -->   3

김CC   --> |--------------------|    -->   5

1~10   Hash

같은 입력 -> 같은 출력

다른 입력 -> 다른 출력

이 **Hash Map**은 **Hash 함수** 의 속도가 얼마나 걸리느냐에 따라 다르다.

보통 $O(1)$~상수~이 걸린다고 할 수 있다. 

배열로 된것은 $O(N)$

바이너리서치트리로 만든 것은 $O(log_2N)$

Hash Map은 $O(1)$의 시간이 걸리는데 상수는 거의 시간이 안걸린다고 볼 수 있다.

#### Hash

1. 출력 값의 범위가 있다.
   - ex) 0~99

2. 같은 입력이면 같은 출력이 나온다.
3. 다른 입력이면 보통의 경우에 다른 출력이 나온다.(어려운 문제이다.)



​               입력

​          --------\       /--------

​         |           함수           |

​          --------------/      \ ---

​                             출력



**Hash**를 할 때 **Modular**를 많이 쓴다. **Modular**는 one-way function 이라고 한다.

출력 값이 정해져 있는 값은 어떻게 정해줄까요?

사인 세타를 싸면 모든 값이 -1~1사이에 존재한다. 대부분의 경우 다른 값을 출력하지만 가끔씩 같은 값을 출력한다.

**Modular**는 나머지 연산을 의미한다. % = **Modular**

13%12 = 1

14%12 = 2

Mod N

0~N-1이 나온다.

**Sin0** 는 -1~1

정수 -> 실수

2차 함수라서 계산이 복잡하다.

**Modular**

정수 -> 정수

1차 함수라서 계산이 간단하다.

그래서 **Modular**를 많이 쓴다.

. **Modular**는 one-way function 이라고 한다.

왜냐하면 N을 넣었을 때 3이 나왔다고 하면 반대로 계산 했을 때 3의 값이 출력값으로 가질 수 있는 수는 무한대에 가깝다.

X Mod N = M

무한대의 후보군이 있다.

Sin0 = $1/2$

이 또한 무한대의 후보군이 있다.



현대 컴퓨터에서는 **Hash**가 매우  중요하다.  특히 보안에 중요하다.

"abcd" --> Hash --> 257624

같은 입력 값에서는 같은 출력 값이 나온다. 그렇기 때문에 출력 값만 가지고는 본 입력 값을 알 수가 없다.

**Hash**가 쓰이는 곳

- 공개키 암호화
- Checksum
- 블록체인

굉장히 다양한 곳에 쓰이고 있다.



----

# 해볼 것

Rolling hash

"abcde"

S~0~...S~n~

H~i~ = H~i-1~ X A + S~i~) % B

"abcde"

H~0~=(S~0~) % B

H~1~=(H~0~ X A + S~1~) % B ...

A = 256

B=  소수로 잡는 것이 좋다.

B = 3571

---

# Golang 에서의 Map

 **golang**에서 제공하는 **Map**에 대해서 알아보도록하자

```go
package main

import "fmt"

func main() {
    var m map[{키 타입}]{밸류 타입}
    m = make(map[{키 타입}]{밸류 타입}) //맵을 만들고 초기화를 해야한다. 아니면 에러난다.
    
    m["{키 값}"] ="{밸류 값}"
    fmt.Println(m["키 값"])
    
    fmt.Println(m1[{없는 키 값}])//없는 키 값을 넣으면 그 타입의 기본 값이 나온다.
}
```

없는 키 값을 프린트 하게 되면 그 **타입의 기본 값**이 나온다.

```go
package main

import "fmt"

func main() {
	var m map[string]string
	m = make(map[string]string)

	m["bcd"] = "ccc"
	fmt.Println(m["bcd"])

	m1 := make(map[int]string) //선언과 초기화를 같이 할 수 있다.
	m1[53] = "ddd"
	fmt.Println(m1[53])

	fmt.Println("m1[55] = ", m1[55])// ""빈 문자열

	m2 := make(map[int]int)
	m2[4] = 4
	fmt.Println("m2[10]=", m2[10]) // 0
	
	m3 := make(map[int]bool)

	m3[4] = true

	fmt.Println(m3[6], m3[4]) //false true
```

 이렇듯 기본 형이 나오지만 int의 기본 형인 '0'의 경우 내가 직접 입력한 값인지 아니면 비어있는데 기본 형으로 반환 된 값인지 알 수 없게 된다.

 그래서 **Golang**은 다음과 같은 기능을 제공한다.

```go
//...
	m2 := make(map[int]int)
	m2[4] = 4
	fmt.Println("m2[10]=", m2[10]) // 0
	
    m2[5] = 0
    fmt.Println("m2[5]="m m2[5]) // 0; 다음과 같을 때 혼란이 온다.
    //그래서 다음과 같은 기능을 제공한다.
  
    v1, ok1 := m2[5]
    v2, ok2 := m2[6]
    fmt.Println(v1, ok1, v2, ok2) //0 true 0 false 
//...

```

이렇듯 두번 째 반환 값을 **bool**형으로 반환 하여 값이 입력한 값인지 **int** 타입의 기본 형인지 알 수 있다.

지우는 방법은 다음과 같다.

```go
//...
delete({맵 이름}, {키 값})
//...
```

예시는 다음과 같다.

```go
//...
    v1, ok1 := m2[5]
    v2, ok2 := m2[6]
    fmt.Println(v1, ok1, v2, ok2) //0 true 0 false 

    delete(m2, 5)
    v1, ok1 = m2[5]
    fmt.Println(v1, ok1, v2, ok2) //0 false 0 false
//...
```

 위와 같은 예시를 통해 우리는 **v1**의 값이 지워졌다는 것을 알 수 있다.

 다음은 **Map**을 순회하는 방법이다. **for문**을 이용한다.

```go
//...
	m2[2] = 98
	m2[10] = 1245

	for key, value := range m2 {
		fmt.Println(key, " = ", value) 
        //4 = 4
        //2 = 98
        //10 = 1245
//...
```

 맵을 이용하여 정렬된 형태로 뽑아낼 수 없다. 정렬하려면 키 값으로 정렬을 해야한다.