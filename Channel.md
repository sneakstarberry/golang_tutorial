# Channel

#### Channel 은

`Fixed sized` 고정 된 크기를 갖고,

`Thread Safe` 쓰레드에서 안정적으로 돌아가는

`Queue`이다.

**Channel**은 **queue**인데 이것을 선언하고 초기화 하는 방법을 알아보도록 하자.

`chan`(channel)이라고 한다.

```go
var {값} chan {값의 타입}(모든 타입 가능하다.)
ex)
var a chan int
a := make(chan int, 10)
```

초기화를 해주어야 한다. 사이즈를 적을 수도 있다. chan은 고정된 사이즈를 갖는다.

그래서 채널을 그냥 만들게 되면 1개짜리가 아닌 0개 짜리 채널을 만들게 된다.

채널은 push, pop 기능을 제공한다.

아래와 같이 이용할 수 있다.

```go
//...
c := make(chan int, 1)
c <- 10 // Push 값을 더할 때
v := <- c // Pop 값을 뺄 때

fmt.Println(v) // 10
//...
```

길이가 0 짜리인 chan은 다른 곳에서 값을 빼줄 때까지 작업을 기다린다.

예시는 다음과 같다.

``` go
package main

import "fmt"

func pop(c chan int) {
	fmt.Println("Pop func")
	v := <-c
	fmt.Println(v)
}

func main() {
	var c chan int
	c= make(chan int, 0)

	go pop(c)
	c <- 10

	fmt.Println("end of program")
}
```

| main                                                         | pop                                        |
| ------------------------------------------------------------ | ------------------------------------------ |
| c = make(chan int, 0)    →                                   | fmt.Println("Pop func")  ↓                 |
| c <- 10 \| 값을 넣었을 때 길이가 0개 짜리기<br />때문에 값이 빠질때 까지 기다린다. | v := <- c    c에 값이 없기 때문에 기다린다 |
| 값이 빠인후 "end of program"을 프린트한다.                   | "10"의 값을 찍게 되고                      |



GoLang 에서 제공하는  Go Thread와 Channel 그리고 Select를 제공하고 있다. 이 세가지를 통해 멀티쓰레드를 효율적으로 잘 만들 수가 있다. GoLang의 가장 큰 장점 중 하나이다.



### 멀티쓰레드를 왜 사용해야 하는가?

답은 효율적으로 만들기 위해, 머신의 성능을 최대한 이용하기 위해서 이다.

멀티쓰레드가 꼭 필요한 이유는 공짜 점심이 끝났기 때문이다.

무어의 법칙이 있는데 CPU가 1년에 2배 씩 성능이 좋아진다. 

여태껏 그래 왔지만 이제 그러한 무어의 법칙이 깨졌다.

물리적 한계로 CPU 성능 향상에 실패했다.

그래서 멀티 코어로 가게 되었다. 

그 동안 프로그램이 저절로 2배씩 빨라졌는데 이제는 그렇지 않기 때문에 멀티 쓰레드를 써야한다.

하지만 굳이 멀티 쓰레드를 하지 않아도 된다. 멀티 프로세스를 해도 된다.

1개의 프로세스가 4개의 쓰레드를 가지고 있는 것과 4개의 프로세스가 1개 씩 쓰레드를 가지는 것과 같다.

